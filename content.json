[{"title":"JVM(Ⅲ)-垃圾回收算法","date":"2016-12-11T14:42:56.000Z","path":"2016/12/11/JVM(Ⅲ)-垃圾回收算法/","text":"标记-清除算法对即将回收的对象进行标记，等到下次垃圾回收时一并回收。缺点：产生大量空间碎片，可能导致下次需要连续内存空间的对象初始化时申请内存失败。 标记-整理算法基于标记-清除算法，多加一个整理功能。对于即将回收的对象进行标记，并且把存活的对象移到一端，等到下次垃圾回收时将另一端的内存全部回收。 复制算法将内存分为等量的两块，每一次只使用其中一块。当这一块的内存用完了就把还存活着的对象全部复制到另一块内存上，并清空刚使用的那一块的内存。 分代收集算法Java虚拟机将内存分为新生代和老年代来回收垃圾。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅱ)-GC前的对象死亡判定","date":"2016-12-09T13:17:49.000Z","path":"2016/12/09/JVM(Ⅱ)-GC前的对象死亡判定/","text":"判定对象不可用的方法 引用计数算法 根搜索算法 引用计数算法对象每新增一个引用，该对象的计数器值加1。对象每减少一个引用，该对象的计数器值减1。任何时候计数器值为0，该对象不可用。 缺点：无法解决对象死循环引用情况。 根搜索算法一个对象没有任何引用链能到达GC Roots即为不可用。 引用两种判定对象不可用的方法都涉及到引用。引用又分为四种： 强引用：只要强引用还存在，垃圾回收器永远都不会对其引用对象回收。 软引用：还有用，但不是必要的引用。内存溢出前将其放入可回收队列，进行二次回收。 弱引用：只能存活到下次垃圾回收前。 虚引用：仅仅起到接受系统回收对象的通知。 判定不可用对象死亡的条件第一次标记：不可用对象覆盖了finalize()方法且没被虚拟机调用过，则虚拟机触发finalize()方法，由于是低优先级线程，所以并不一定执行finalize()，仅仅只是触发。第二次标记：弱第一次标记中的对象执行了finalize()并且新增了引用，则该对象移出“即将回收”的集合。反之对象死亡回收。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅰ)-内存管理机制","date":"2016-12-09T10:57:18.000Z","path":"2016/12/09/JVM(Ⅰ)-内存管理机制/","text":"Java虚拟机主要内存区域 栈 堆 方法区 如图： 栈Java虚拟机栈用于存放Java执行时的方法，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表等信息。 堆Java堆是Java虚拟机管理中最大的一块区域，目的是用于存放对象实例。Java堆物理上可以不连续，逻辑上连续即可。 方法区方法区虽然有个别名叫做非堆，但实际上它是堆的一个逻辑部分，所以在图中我把它放在了堆里面较为妥当。方法区中还有个重要的部分是运行时常量池，用于存放类加载后的静态常量，符号符号引用和常量池。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]