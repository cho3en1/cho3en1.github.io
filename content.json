[{"title":"Java常用容器汇总及比较","date":"2016-12-21T21:39:07.000Z","path":"2016/12/22/Java常用容器汇总及比较/","text":"Java常用容器类图 各容器接口特点Set：无序、不可重复List：有序、可重复Map：键值对方式存放 各容器底层实现方式HashSet：HashMapArrayList：数组Vector：数组LinkList：双向链表HashMap：数组+链表HashTable：数组+链表 同接口各容器效率比较Set：HashSet List：ArrayList：查询快、修改 插入 删除慢Vector：本质为实现了线程安全的ArrayList、效率低LinkList：查询慢、修改 插入 删除快 Map：HashMapHashTable：本质为实现了线程安全的HashMap、效率低","tags":[{"name":"Set List Map","slug":"Set-List-Map","permalink":"http://yoursite.com/tags/Set-List-Map/"}]},{"title":"JVM(Ⅴ)-类加载机制","date":"2016-12-13T08:01:05.000Z","path":"2016/12/13/JVM(Ⅴ)-类加载机制/","text":"类生命周期图 类加载过程 加载 链接 初始化 加载 将二进制的类文件转化为虚拟机可执行的Java格式，并将类的相关静态数据存放到方法区。 在堆上创建一个该类的类对象，作为接口访问该类的数据。 链接 验证：检查代码是否符合虚拟机要求。 准备：为类的静态变量赋初值。 解析：将常量池里面的符号引用替换为直接引用。 初始化给类的静态变量初始化值。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅳ)-垃圾回收机制","date":"2016-12-11T16:07:57.000Z","path":"2016/12/12/JVM(Ⅳ)-垃圾回收机制/","text":"JVM垃圾回收区域堆内存分布图 年轻代垃圾回收机制详情 新创建的对象大部分分配在新生代Eden区上。 当Eden区没有足够的空间的时候虚拟机发起一次MinorGC，通过复制算法将Eden区存活的对象复制到其中一块Survivor区S0，并清空Eden区。 下一次Eden区满的时候虚拟机再发起一次MinorGC，通过复制算法将Eden区和S0区中存活的对象一并复制到另一块Survivor区S1，并清空Eden区和S0区。 S0和S1功能调换，循环步骤3。 老年代垃圾回收机制详情 Survivor区的对象晋升老年代时，老年代区内存不够的时候虚拟机发起一次MajorGC，通过标记-整理算法回收垃圾。 Survivor区内存不够用时，老年代为其无法容纳的对象进行担保，若担保失败，虚拟机发起一次MajorGC。担保成功与否的判定取决于之前每一次晋升到老年代区的对象的平均大小。若某次MinorGC后存活的对象远远大于这个平均值，则担保必将失败。 对象进入老年代的判定 刚创建的大对象直接进入老年代，大对象的判定由虚拟机的-XX：PretenureSizeThreshold参数确定。 长期存活的对象将进入老年代，长期存活的判定由虚拟机的-XX：MaxTenuringThreshold参数确定，对象在Survivor区中每经历一次MinorGC，年龄就增长一岁。 MinorGC后存活了大量的对象，这时Survivor区内存将不够用。这时Survivor区无法容纳的对象将直接进入老年代。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅲ)-垃圾回收算法","date":"2016-12-11T14:42:56.000Z","path":"2016/12/11/JVM(Ⅲ)-垃圾回收算法/","text":"标记-清除算法对即将回收的对象进行标记，等到下次垃圾回收时一并回收。缺点：产生大量空间碎片，可能导致下次需要连续内存空间的对象初始化时申请内存失败。 标记-整理算法基于标记-清除算法，多加一个整理功能。对于即将回收的对象进行标记，并且把存活的对象移到一端，等到下次垃圾回收时将另一端的内存全部回收。 复制算法将内存分为等量的两块，每一次只使用其中一块。当这一块的内存用完了就把还存活着的对象全部复制到另一块内存上，并清空刚使用的那一块的内存。 分代收集算法Java虚拟机将内存分为新生代和老年代来回收垃圾。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅱ)-GC前的对象死亡判定","date":"2016-12-09T13:17:49.000Z","path":"2016/12/09/JVM(Ⅱ)-GC前的对象死亡判定/","text":"判定对象不可用的方法 引用计数算法 根搜索算法 引用计数算法对象每新增一个引用，该对象的计数器值加1。对象每减少一个引用，该对象的计数器值减1。任何时候计数器值为0，该对象不可用。 缺点：无法解决对象死循环引用情况。 根搜索算法一个对象没有任何引用链能到达GC Roots即为不可用。 引用两种判定对象不可用的方法都涉及到引用。引用又分为四种： 强引用：只要强引用还存在，垃圾回收器永远都不会对其引用对象回收。 软引用：还有用，但不是必要的引用。内存溢出前将其放入可回收队列，进行二次回收。 弱引用：只能存活到下次垃圾回收前。 虚引用：仅仅起到接受系统回收对象的通知。 判定不可用对象死亡的条件第一次标记：不可用对象覆盖了finalize()方法且没被虚拟机调用过，则虚拟机触发finalize()方法，由于是低优先级线程，所以并不一定执行finalize()，仅仅只是触发。第二次标记：弱第一次标记中的对象执行了finalize()并且新增了引用，则该对象移出“即将回收”的集合。反之对象死亡回收。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅰ)-内存管理机制","date":"2016-12-09T10:57:18.000Z","path":"2016/12/09/JVM(Ⅰ)-内存管理机制/","text":"Java虚拟机主要内存区域 栈 堆 方法区 如图： 栈Java虚拟机栈用于存放Java执行时的方法，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表等信息。 堆Java堆是Java虚拟机管理中最大的一块区域，目的是用于存放对象实例。Java堆物理上可以不连续，逻辑上连续即可。 方法区方法区虽然有个别名叫做非堆，但实际上它是堆的一个逻辑部分，所以在图中我把它放在了堆里面较为妥当。方法区中还有个重要的部分是运行时常量池，用于存放类加载后的静态常量，符号符号引用和常量池。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]