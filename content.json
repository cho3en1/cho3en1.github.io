[{"title":"JDBC连接数据库","date":"2016-12-31T17:30:41.000Z","path":"2017/01/01/JDBC连接数据库/","text":"12345678910Class.forName(&quot;com.mysql.jdbc.Driver&quot;);String url = &quot;jdbc:mysql://localhost/database&quot;;String user = &quot;username&quot;;String password = &quot;password&quot;;Connection conn = DriverManager.getConnection(url, user, password);String sql = &quot;SELECT * FROM table WHERE username=? AND password=?&quot;;pstmt.setString(1, admin);pstmt.setString(2, 000000);PreparedStatement pstmt = conn.prepareStatement(sql);ResultSet rs = pstmt.executeQuery();","tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"GOF设计模式(Ⅰ)-单例模式","date":"2016-12-24T19:50:41.000Z","path":"2016/12/25/GOF设计模式(Ⅰ)-单例模式/","text":"Ⅰ：私有静态属性Ⅱ：私有构造器Ⅲ：提供一个静态方法供外界获取静态实例 单例模式五种常见实现方式Ⅰ：饿汉式（线程安全，调用效率高，不能延时加载）Ⅱ：懒汉式（线程安全，调用效率不高，能延时加载）Ⅲ：枚举单例（线程安全，调用效率高，不能延时加载）Ⅳ：静态内部类式（线程安全，调用效率高，能延时加载）Ⅴ：双重检测锁式（JVM内存模型原因，偶尔会出问题，不建议使用） 饿汉式1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return intence; &#125;&#125; 懒汉式12345678910public class Singleton &#123; private static Singleton instance; private Singleton(); public static synchronized Singleton getInstance &#123; if(instance==null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 枚举单例123public enum Singleton &#123; INSTANCE;&#125; 静态内部类式123456789public class Singleton &#123; private static class SingletonHolder &#123; private static Singleton instance = new Singleton(); &#125; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125;&#125; 双重检测锁式1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized(Sinleton.class) &#123; if(instance==null) &#123; instance = new Singletance(); &#125; &#125; &#125; return instance; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Java网络编程小结","date":"2016-12-23T18:34:10.000Z","path":"2016/12/24/Java网络编程小结/","text":"TCP建立连接三次握手通信图SYN：标志位，同步标志。SYN置1：发起一个新的请求ACK：标志位，确认标志。ACK置1：确认序列号有效seq：序列号。指出该数据在发送端数据流中的位置ack：确认号。指出本机希望下一个接收的字节的序列号 TCP三次握手过程Ⅰ：客户端发送一个同步数据包请求连接，初始序列号seq由客户端随机产生一个值xⅡ：服务器端接收到客户端的同步数据包，将对该客户端进行同步确认。服务器端发送一个同步数据包给客户端，初始序列号seq由服务其端随机产生一个值y，确认号ack=x+1Ⅲ：客户端接收到服务器端的同步数据包，对服务器端进行确认。确认号ack=y+1 Socket通信模型","tags":[{"name":"TCP Socket","slug":"TCP-Socket","permalink":"http://yoursite.com/tags/TCP-Socket/"}]},{"title":"Java多线程小结","date":"2016-12-22T18:50:33.000Z","path":"2016/12/23/Java多线程小结/","text":"Java线程状态机图简版 Java线程状态机图完整版 Java线程生命周期新生状态： new线程即为新生状态1Ⅰ：线程执行start()方法后，进入就绪状态 就绪状态： 线程执行Start()方法后即为就绪状态1Ⅰ：线程被CPU调度并且被分配到时间片后，进入运行状态执行run()方法 运行状态： 线程获取到CPU分配的时间后即为运行状态。123Ⅰ：线程在CPU分配的时间片内未运行完，重新回到就绪状态Ⅱ：线程遭遇阻塞事件的发生（join yield sleep wait IO），进入阻塞状态Ⅲ：线程执行完毕，进入死亡状态 阻塞状态： 线程在运行时遭遇阻塞事件的发生后即为阻塞状态1Ⅰ：阻塞事件解除后，线程回到就绪状态 死亡状态： 线程正常执行结束或外部干涉而执行结束后即为死亡状态1Ⅰ：死亡状态的线程对象将被JVM执行垃圾回收 创建线程Ⅰ：继承Thread重写run()方法Ⅱ：实现Runnable接口重写run()方法 线程优先级线程优先级只是概率，优先级越高的线程被CPU调度的概率越大，并不是绝对的先后顺序OK？setPriority()方法设置线程优先级大小，范围1~10，默认值5 线程阻塞事件Ⅰ：线程合并 join()Ⅱ：线程暂停 yield()Ⅲ：线程睡眠 sleep() 线程同步多个线程访问同一对象资源时，为确保资源安全，需对该资源进行锁定synchronized1234Ⅰ：同步块synchronized(引用类型 | this | 类.class) &#123;&#125; Ⅱ：同步方法修饰符 synchronized 线程死锁过多的线程同步容易造成线程死锁1234567891011121314151617181920212223242526272829303132333435Object A;Object B;main() &#123; Thread1 t1; Thread2 t2; t1.start(); t2.start();&#125;Thread1 &#123; run() &#123; method1(); &#125; method1() &#123; synchronized(A) &#123; ... synchronized(B) &#123;...&#125; ... &#125; &#125;&#125;Thread2 &#123; run() &#123; method2(); &#125; method2() &#123; synchronized(B) &#123; ... synchronized(A) &#123;...&#125; ... &#125; &#125;&#125;","tags":[{"name":"Thread","slug":"Thread","permalink":"http://yoursite.com/tags/Thread/"}]},{"title":"Java常见容器汇总","date":"2016-12-21T21:39:07.000Z","path":"2016/12/22/Java常见容器汇总/","text":"Java常见容器类图 各容器接口特点Set：无序、不可重复List：有序、可重复Map：键值对方式存放 各容器底层实现方式HashSet：HashMapArrayList：数组Vector：数组LinkList：双向链表HashMap：数组+链表HashTable：数组+链表 同接口各容器效率比较Set：HashSet List：ArrayList：查询快、修改 插入 删除慢Vector：本质为实现了线程安全的ArrayList、效率低LinkList：查询慢、修改 插入 删除快 Map：HashMapHashTable：本质为实现了线程安全的HashMap、效率低","tags":[{"name":"Set List Map","slug":"Set-List-Map","permalink":"http://yoursite.com/tags/Set-List-Map/"}]},{"title":"JVM(Ⅴ)-类加载机制","date":"2016-12-13T08:01:05.000Z","path":"2016/12/13/JVM(Ⅴ)-类加载机制/","text":"类生命周期图 类加载过程 加载 链接 初始化 加载 将二进制的类文件转化为虚拟机可执行的Java格式，并将类的相关静态数据存放到方法区。 在堆上创建一个该类的类对象，作为接口访问该类的数据。 链接 验证：检查代码是否符合虚拟机要求。 准备：为类的静态变量赋初值。 解析：将常量池里面的符号引用替换为直接引用。 初始化给类的静态变量初始化值。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅳ)-垃圾回收机制","date":"2016-12-11T16:07:57.000Z","path":"2016/12/12/JVM(Ⅳ)-垃圾回收机制/","text":"JVM垃圾回收区域堆内存分布图 年轻代垃圾回收机制详情 新创建的对象大部分分配在新生代Eden区上。 当Eden区没有足够的空间的时候虚拟机发起一次MinorGC，通过复制算法将Eden区存活的对象复制到其中一块Survivor区S0，并清空Eden区。 下一次Eden区满的时候虚拟机再发起一次MinorGC，通过复制算法将Eden区和S0区中存活的对象一并复制到另一块Survivor区S1，并清空Eden区和S0区。 S0和S1功能调换，循环步骤3。 老年代垃圾回收机制详情 Survivor区的对象晋升老年代时，老年代区内存不够的时候虚拟机发起一次MajorGC，通过标记-整理算法回收垃圾。 Survivor区内存不够用时，老年代为其无法容纳的对象进行担保，若担保失败，虚拟机发起一次MajorGC。担保成功与否的判定取决于之前每一次晋升到老年代区的对象的平均大小。若某次MinorGC后存活的对象远远大于这个平均值，则担保必将失败。 对象进入老年代的判定 刚创建的大对象直接进入老年代，大对象的判定由虚拟机的-XX：PretenureSizeThreshold参数确定。 长期存活的对象将进入老年代，长期存活的判定由虚拟机的-XX：MaxTenuringThreshold参数确定，对象在Survivor区中每经历一次MinorGC，年龄就增长一岁。 MinorGC后存活了大量的对象，这时Survivor区内存将不够用。这时Survivor区无法容纳的对象将直接进入老年代。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅲ)-垃圾回收算法","date":"2016-12-11T14:42:56.000Z","path":"2016/12/11/JVM(Ⅲ)-垃圾回收算法/","text":"标记-清除算法对即将回收的对象进行标记，等到下次垃圾回收时一并回收。缺点：产生大量空间碎片，可能导致下次需要连续内存空间的对象初始化时申请内存失败。 标记-整理算法基于标记-清除算法，多加一个整理功能。对于即将回收的对象进行标记，并且把存活的对象移到一端，等到下次垃圾回收时将另一端的内存全部回收。 复制算法将内存分为等量的两块，每一次只使用其中一块。当这一块的内存用完了就把还存活着的对象全部复制到另一块内存上，并清空刚使用的那一块的内存。 分代收集算法Java虚拟机将内存分为新生代和老年代来回收垃圾。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅱ)-GC前的对象死亡判定","date":"2016-12-09T13:17:49.000Z","path":"2016/12/09/JVM(Ⅱ)-GC前的对象死亡判定/","text":"判定对象不可用的方法 引用计数算法 根搜索算法 引用计数算法对象每新增一个引用，该对象的计数器值加1。对象每减少一个引用，该对象的计数器值减1。任何时候计数器值为0，该对象不可用。 缺点：无法解决对象死循环引用情况。 根搜索算法一个对象没有任何引用链能到达GC Roots即为不可用。 引用两种判定对象不可用的方法都涉及到引用。引用又分为四种： 强引用：只要强引用还存在，垃圾回收器永远都不会对其引用对象回收。 软引用：还有用，但不是必要的引用。内存溢出前将其放入可回收队列，进行二次回收。 弱引用：只能存活到下次垃圾回收前。 虚引用：仅仅起到接受系统回收对象的通知。 判定不可用对象死亡的条件第一次标记：不可用对象覆盖了finalize()方法且没被虚拟机调用过，则虚拟机触发finalize()方法，由于是低优先级线程，所以并不一定执行finalize()，仅仅只是触发。第二次标记：弱第一次标记中的对象执行了finalize()并且新增了引用，则该对象移出“即将回收”的集合。反之对象死亡回收。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM(Ⅰ)-内存管理机制","date":"2016-12-09T10:57:18.000Z","path":"2016/12/09/JVM(Ⅰ)-内存管理机制/","text":"Java虚拟机主要内存区域 栈 堆 方法区 如图： 栈Java虚拟机栈用于存放Java执行时的方法，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表等信息。 堆Java堆是Java虚拟机管理中最大的一块区域，目的是用于存放对象实例。Java堆物理上可以不连续，逻辑上连续即可。 方法区方法区虽然有个别名叫做非堆，但实际上它是堆的一个逻辑部分，所以在图中我把它放在了堆里面较为妥当。方法区中还有个重要的部分是运行时常量池，用于存放类加载后的静态常量，符号符号引用和常量池。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]