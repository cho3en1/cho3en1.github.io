[{"title":"GC前的对象死亡判定","date":"2016-12-09T13:17:49.000Z","path":"2016/12/09/JVM(Ⅱ)-GC前的对象死亡判定/","text":"判定对象不可用的方法 引用计数算法 根搜索算法 引用计数算法对象每新增一个引用，该对象的计数器值加1。对象每减少一个引用，该对象的计数器值减1。任何时候计数器值为0，该对象不可用。 缺点：无法解决对象死循环引用情况。 根搜索算法一个对象没有任何引用链能到达GC Roots即为不可用。 引用两种判定对象不可用的方法都涉及到引用。引用又分为四种： 强引用：只要强引用还存在，垃圾回收器永远都不会对其引用对象回收。 软引用：还有用，但不是必要的引用。内存溢出前将其放入可回收队列，进行二次回收。 弱引用：只能存活到下次垃圾回收前。 虚引用：仅仅起到接受系统回收对象的通知。 判定不可用对象死亡的条件第一次标记：不可用对象覆盖了finalize()方法且没被虚拟机调用过，则虚拟机触发finalize()方法，由于是低优先级线程，所以并不一定执行finalize()，仅仅只是触发。第二次标记：弱第一次标记中的对象执行了finalize()并且新增了引用，则该对象移出“即将回收”的集合。反之对象死亡回收。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"JVM内存管理机制","date":"2016-12-09T10:57:18.000Z","path":"2016/12/09/JVM(Ⅰ)-内存管理机制/","text":"Java虚拟机主要内存区域 栈 堆 方法区 如图： 栈Java虚拟机栈用于存放Java执行时的方法，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表等信息。 堆Java堆是Java虚拟机管理中最大的一块区域，目的是用于存放对象实例。Java堆物理上可以不连续，逻辑上连续即可。 方法区方法区虽然有个别名叫做非堆，但实际上它是堆的一个逻辑部分，所以在图中我把它放在了堆里面较为妥当。方法区中还有个重要的部分是运行时常量池，用于存放类加载后的静态常量，符号符号引用和常量池。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]}]